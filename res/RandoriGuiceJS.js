/*Generated by SharpKit 5 v5.00.0000*/
if (typeof ($Inherit) == 'undefined') {
	var $Inherit = function (ce, ce2) {

		if (typeof (Object.getOwnPropertyNames) == 'undefined') {

			for (var p in ce2.prototype)
				if (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p])
					ce.prototype[p] = ce2.prototype[p];
			for (var p in ce2)
				if (typeof (ce[p]) == 'undefined')
					ce[p] = ce2[p];
			ce.$baseCtor = ce2;

		} else {

			var props = Object.getOwnPropertyNames(ce2.prototype);
			for (var i = 0; i < props.length; i++)
				if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined')
					Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));

			for (var p in ce2)
				if (typeof (ce[p]) == 'undefined')
					ce[p] = ce2[p];
			ce.$baseCtor = ce2;

		}

	}
};
if (typeof($CreateException)=='undefined') 
{
    var $CreateException = function(ex, error) 
    {
        if(error==null)
            error = new Error();
        if(ex==null)
            ex = new System.Exception.ctor();       
        error.message = ex.message;
        for (var p in ex)
           error[p] = ex[p];
        return error;
    }
}
if (typeof(guice) == "undefined")
    var guice = {};
if (typeof(guice.binding) == "undefined")
    guice.binding = {};
guice.binding.Binder = function (hashMap)
{
    this.hashMap = null;
    this.hashMap = hashMap;
};
guice.binding.Binder.prototype.getBinding = function (typeDefinition)
{
    return this.hashMap[typeDefinition.getClassName()];
};
guice.binding.Binder.prototype.addBinding = function (binding)
{
    this.hashMap[binding.getTypeName()] = binding;
};
guice.binding.Binder.prototype.bind = function (type)
{
    var typeDefinition = new guice.reflection.TypeDefinition(type);
    var factory = new guice.binding.BindingFactory(this, typeDefinition);
    return factory;
};
guice.binding.Binder.className = "guice.binding.Binder";
guice.binding.Binder.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'hashMap', t:'guice.binding.BindingHashMap', r:'1'});
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.binding.Scope = {Instance: 0, Singleton: 1};
guice.binding.Scope.className = "guice.binding.Scope";
guice.binding.Scope.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.binding.Binding = function ()
{
};
guice.binding.Binding.className = "guice.binding.Binding";
guice.binding.Binding.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.binding.BindingFactory = function (binder, typeDefinition)
{
    this.binder = null;
    this.typeDefinition = null;
    this.scope = guice.binding.Scope.Instance;
    this.binder = binder;
    this.typeDefinition = typeDefinition;
};
guice.binding.BindingFactory.prototype.to = function (dependency)
{
    var binding = this.withDecoration(new guice.binding.TypeBinding(this.typeDefinition, new guice.reflection.TypeDefinition(dependency)));
    this.binder.addBinding(binding);
    return binding;
};
guice.binding.BindingFactory.prototype.toInstance = function (instance)
{
    var binding = new guice.binding.InstanceBinding(this.typeDefinition, instance);
    this.binder.addBinding(binding);
    return binding;
};
guice.binding.BindingFactory.prototype.toProvider = function (providerType)
{
    var binding = this.withDecoration(new guice.binding.ProviderBinding(this.typeDefinition, new guice.reflection.TypeDefinition(providerType)));
    this.binder.addBinding(binding);
    return binding;
};
guice.binding.BindingFactory.prototype.inScope = function (scope)
{
    this.scope = scope;
    return this;
};
guice.binding.BindingFactory.prototype.withDecoration = function (binding)
{
    if (this.scope == guice.binding.Scope.Singleton)
    {
        binding = new guice.binding.SingletonDecorator(binding);
    }
    return binding;
};
guice.binding.BindingFactory.className = "guice.binding.BindingFactory";
guice.binding.BindingFactory.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'binder', t:'guice.binding.Binder', r:'1'});
            p.push({n:'typeDefinition', t:'guice.reflection.TypeDefinition', r:'1'});
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.binding.InstanceBinding = function (typeDefinition, instance)
{
    this.typeDefinition = null;
    this.instance = null;
    guice.binding.Binding.call(this);
    this.typeDefinition = typeDefinition;
    this.instance = instance;
};
guice.binding.InstanceBinding.prototype.getTypeName = function ()
{
    return this.typeDefinition.getClassName();
};
guice.binding.InstanceBinding.prototype.provide = function (injector)
{
    return this.instance;
};
$Inherit(guice.binding.InstanceBinding, guice.binding.Binding);
guice.binding.InstanceBinding.className = "guice.binding.InstanceBinding";
guice.binding.InstanceBinding.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'typeDefinition', t:'guice.reflection.TypeDefinition', r:'1'});
            p.push({n:'instance', r:'1'});
            break;
        case 1:
            p = guice.binding.Binding.injectionPoints(t);
            break;
        case 3:
            p = guice.binding.Binding.injectionPoints(t);
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.binding.Provider = function ()
{
};
guice.binding.Provider.className = "guice.binding.Provider";
guice.binding.Provider.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.binding.ProviderBinding = function (typeDefinition, providerTypeDefinition)
{
    this.typeDefinition = null;
    this.providerTypeDefinition = null;
    this.provider = null;
    guice.binding.Binding.call(this);
    this.typeDefinition = typeDefinition;
    this.providerTypeDefinition = providerTypeDefinition;
};
guice.binding.ProviderBinding.prototype.getTypeName = function ()
{
    return this.typeDefinition.getClassName();
};
guice.binding.ProviderBinding.prototype.provide = function (injector)
{
    if (this.provider == null)
    {
        this.provider = injector.getInstance$$TypeDefinition(this.providerTypeDefinition);
    }
    return this.provider.get();
};
$Inherit(guice.binding.ProviderBinding, guice.binding.Binding);
guice.binding.ProviderBinding.className = "guice.binding.ProviderBinding";
guice.binding.ProviderBinding.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'typeDefinition', t:'guice.reflection.TypeDefinition', r:'1'});
            p.push({n:'providerTypeDefinition', t:'guice.reflection.TypeDefinition', r:'1'});
            break;
        case 1:
            p = guice.binding.Binding.injectionPoints(t);
            break;
        case 3:
            p = guice.binding.Binding.injectionPoints(t);
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.binding.SingletonDecorator = function (binding)
{
    this.sourceBinding = null;
    this.instance = null;
    guice.binding.Binding.call(this);
    this.sourceBinding = binding;
};
guice.binding.SingletonDecorator.prototype.getTypeName = function ()
{
    return this.sourceBinding.getTypeName();
};
guice.binding.SingletonDecorator.prototype.provide = function (injector)
{
    if (this.instance == null)
    {
        this.instance = this.sourceBinding.provide(injector);
    }
    return this.instance;
};
$Inherit(guice.binding.SingletonDecorator, guice.binding.Binding);
guice.binding.SingletonDecorator.className = "guice.binding.SingletonDecorator";
guice.binding.SingletonDecorator.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'binding', t:'guice.binding.Binding', r:'1'});
            break;
        case 1:
            p = guice.binding.Binding.injectionPoints(t);
            break;
        case 3:
            p = guice.binding.Binding.injectionPoints(t);
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.binding.TypeBinding = function (typeDefinition, dependencyDefinition)
{
    this.typeDefinition = null;
    this.dependencyDefinition = null;
    guice.binding.Binding.call(this);
    this.typeDefinition = typeDefinition;
    this.dependencyDefinition = dependencyDefinition;
};
guice.binding.TypeBinding.prototype.getTypeName = function ()
{
    return this.typeDefinition.getClassName();
};
guice.binding.TypeBinding.prototype.provide = function (injector)
{
    return injector.buildClass(this.dependencyDefinition.get_type());
};
$Inherit(guice.binding.TypeBinding, guice.binding.Binding);
guice.binding.TypeBinding.className = "guice.binding.TypeBinding";
guice.binding.TypeBinding.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'typeDefinition', t:'guice.reflection.TypeDefinition', r:'1'});
            p.push({n:'dependencyDefinition', t:'guice.reflection.TypeDefinition', r:'1'});
            break;
        case 1:
            p = guice.binding.Binding.injectionPoints(t);
            break;
        case 3:
            p = guice.binding.Binding.injectionPoints(t);
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.InjectionClassBuilder = function (injector, classResolver)
{
    this.injector = null;
    this.classResolver = null;
    this.injector = injector;
    this.classResolver = classResolver;
};
guice.InjectionClassBuilder.prototype.buildClass$$String = function (className)
{
    var type = this.classResolver.resolveClassName(className);
    return this.injector.getInstance$$TypeDefinition(type);
};
guice.InjectionClassBuilder.prototype.buildClass$$String$$Object$Array = function (className, list)
{
    var instance;
    var type = this.classResolver.resolveClassName(className);
    instance = type.constructorApply(list);
    this.injector.injectMembers(instance);
    return instance;
};
guice.InjectionClassBuilder.className = "guice.InjectionClassBuilder";
guice.InjectionClassBuilder.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'injector', t:'guice.Injector', r:'1'});
            p.push({n:'classResolver', t:'guice.resolvers.ClassResolver', r:'1'});
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.GuiceModule = function ()
{
};
guice.GuiceModule.className = "guice.GuiceModule";
guice.GuiceModule.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.GuiceJs = function ()
{
};
guice.GuiceJs.prototype.createInjector = function (module)
{
    var hashMap = new Object();
    var binder = new guice.binding.Binder(hashMap);
    var loader = new guice.loader.SynchronousClassLoader(new XMLHttpRequest(), "generated/");
    var classResolver = new guice.resolvers.ClassResolver(loader);
    if (module != null)
    {
        module.configure(binder);
    }
    var injector = new guice.Injector(binder, classResolver);
    binder.bind(Typeof(guice.Injector)).toInstance(injector);
    binder.bind(Typeof(guice.resolvers.ClassResolver)).toInstance(classResolver);
    binder.bind(Typeof(guice.loader.SynchronousClassLoader)).toInstance(loader);
    return injector;
};
guice.GuiceJs.className = "guice.GuiceJs";
guice.GuiceJs.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.Injector = function (binder, classResolver)
{
    this.binder = null;
    this.classResolver = null;
    this.binder = binder;
    this.classResolver = classResolver;
};
guice.Injector.prototype.getInstance$$Type = function (dependency)
{
    return this.resolveDependency(new guice.reflection.TypeDefinition(dependency));
};
guice.Injector.prototype.getInstance$$TypeDefinition = function (dependencyTypeDefinition)
{
    return this.resolveDependency(dependencyTypeDefinition);
};
guice.Injector.prototype.buildClass = function (dependency)
{
    var type = dependency;
    var constructorPoints;
    var fieldPoints;
    var instance;
    constructorPoints = type.getConstructorParameters();
    instance = this.buildFromInjectionInfo(type, constructorPoints);
    fieldPoints = type.getInjectionFields();
    this.injectMembersFromInjectionInfo(instance, fieldPoints);
    return instance;
};
guice.Injector.prototype.injectMembers = function (instance)
{
    var constructor = instance.constructor;
    var dependency = new guice.reflection.TypeDefinition(constructor);
    var fieldPoints;
    fieldPoints = dependency.getInjectionFields();
    this.injectMembersFromInjectionInfo(instance, fieldPoints);
};
guice.Injector.prototype.buildFromInjectionInfo = function (dependency, constructorPoints)
{
    var args =  [];
    for (var i = 0; i < constructorPoints.length; i++)
    {
        args[i] = this.resolveDependency(this.classResolver.resolveClassName(constructorPoints[i].t));
    }
    var obj = dependency.constructorApply(args);
    return obj;
};
guice.Injector.prototype.injectMembersFromInjectionInfo = function (instance, fieldPoints)
{
    var instanceMap = instance;
    for (var i = 0; i < fieldPoints.length; i++)
    {
        instanceMap[fieldPoints[i].n] = this.resolveDependency(this.classResolver.resolveClassName(fieldPoints[i].t));
    }
};
guice.Injector.prototype.resolveDependency = function (dependency)
{
    var binding = this.binder.getBinding(dependency);
    var instance;
    if (binding != null)
    {
        instance = binding.provide(this);
    }
    else
    {
        instance = this.buildClass(dependency);
    }
    return instance;
};
guice.Injector.className = "guice.Injector";
guice.Injector.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'binder', t:'guice.binding.Binder', r:'1'});
            p.push({n:'classResolver', t:'guice.resolvers.ClassResolver', r:'1'});
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
if (typeof(guice.resolvers) == "undefined")
    guice.resolvers = {};
guice.resolvers.ClassResolver = function (loader)
{
    this.loader = null;
    this.loader = loader;
};
guice.resolvers.ClassResolver.prototype.resolveClassName = function (qualifiedClassName)
{
    var type = this.findDefinition(qualifiedClassName);
    if (type == null)
    {
        var classDefinition = this.loader.loadClass(qualifiedClassName);
        this.resolveParentClassFromDefinition(qualifiedClassName, classDefinition);
        this.addDefinition(classDefinition);
        type = this.findDefinition(qualifiedClassName);
        if (type == null)
        {
            alert(qualifiedClassName + " does not contain required injection information ");
            throw $CreateException(new Error(qualifiedClassName + " does not contain required injection information "), new Error());
        }
    }
    return new guice.reflection.TypeDefinition(type);
};
guice.resolvers.ClassResolver.prototype.resolveParentClassFromDefinition = function (qualifiedClassName, classDefinition)
{
    var inheritString = "\\$Inherit\\(";
    inheritString += qualifiedClassName;
    inheritString += ",([\\w\\W]*?)\\)";
    var inheritResult = classDefinition.match(inheritString);
    if (inheritResult != null)
    {
        this.resolveClassName(inheritResult[1]);
    }
};
guice.resolvers.ClassResolver.prototype.findDefinition = function (qualifiedClassName)
{
    var nextLevel = eval("window");
    var failed = false;
    var path = qualifiedClassName.split(".");
    for (var i = 0; i < path.length; i++)
    {
        nextLevel = nextLevel[path[i]];
        if (nextLevel == undefined)
        {
            failed = true;
            break;
        }
    }
    if (failed)
    {
        return null;
    }
    return nextLevel;
};
guice.resolvers.ClassResolver.prototype.addDefinition = function (definitionText)
{
      
    var isIndirectEvalGlobal = (function (original, Object) {
        try {
            // Does `Object` resolve to a local variable, or to a global, built-in `Object`,
            // reference to which we passed as a first argument?
            return (1, eval)('Object') === original;
        }
        catch (err) {
            // if indirect eval errors out (as allowed per ES3), then just bail out with `false`
            return false;
        }
    })(Object, 123);

    if (isIndirectEvalGlobal) {

        // if indirect eval executes code globally, use it
        return function (expression) {
            return (1, eval)(expression);
        };
    }
    else if (typeof window.execScript !== 'undefined') {

        // if `window.execScript exists`, use it
        return function (expression) {
            return window.execScript(expression);
        };
    }

    // otherwise, globalEval is `undefined` since nothing is returned
;
};
guice.resolvers.ClassResolver.className = "guice.resolvers.ClassResolver";
guice.resolvers.ClassResolver.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'loader', t:'guice.loader.SynchronousClassLoader', r:'1'});
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
if (typeof(guice.reflection) == "undefined")
    guice.reflection = {};
guice.reflection.InjectionTypes = {Constructor: 0, Property: 1, Method: 2, View: 3};
guice.reflection.InjectionTypes.className = "guice.reflection.InjectionTypes";
guice.reflection.InjectionTypes.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
guice.reflection.TypeDefinition = function (type)
{
    this._type = null;
    if (type == null)
    {
        throw $CreateException(new Error("Cannot build class injection of primitives not supported at this time "), new Error());
    }
    this._type = type;
};
guice.reflection.TypeDefinition.prototype.get_type = function ()
{
    return this._type;
};
guice.reflection.TypeDefinition.prototype.injectionPoints = function (injectionType)
{
    return this._type.injectionPoints(injectionType);
};
guice.reflection.TypeDefinition.prototype.getClassName = function ()
{
    var className = this._type.className;
    if (className == undefined)
    {
        throw $CreateException(new Error("Class not does defined a usable className"), new Error());
    }
    return className;
};
guice.reflection.TypeDefinition.prototype.getSuperClassName = function ()
{
    var className = this._type.superClassName;
    if (className == undefined)
    {
        className = "Object";
    }
    return className;
};
guice.reflection.TypeDefinition.prototype.getInjectionFields = function ()
{
    return this.injectionPoints(guice.reflection.InjectionTypes.Property);
};
guice.reflection.TypeDefinition.prototype.getViewFields = function ()
{
    return this.injectionPoints(guice.reflection.InjectionTypes.View);
};
guice.reflection.TypeDefinition.prototype.getConstructorParameters = function ()
{
    return this.injectionPoints(guice.reflection.InjectionTypes.Constructor);
};
guice.reflection.TypeDefinition.prototype.constructorApply = function (args)
{
    var instance = null;
      
    var f, c;
    c = this._type; // get reference to class constructor function
    f = function(){}; // dummy function
    f.prototype = c.prototype; // reference same prototype
    instance = new f(); // instantiate dummy function to copy prototype properties
    c.apply(instance, args); // call class constructor, supplying new object as context
    instance.constructor = c; // assign correct constructor (not f)
;
    return instance;
};
guice.reflection.TypeDefinition.className = "guice.reflection.TypeDefinition";
guice.reflection.TypeDefinition.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'type', r:'1'});
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
if (typeof(guice.loader) == "undefined")
    guice.loader = {};
guice.loader.SynchronousClassLoader = function (xmlHttpRequest, dynamicClassBaseUrl)
{
    this.xmlHttpRequest = null;
    this.dynamicClassBaseUrl = null;
    this.xmlHttpRequest = xmlHttpRequest;
    this.dynamicClassBaseUrl = dynamicClassBaseUrl;
};
guice.loader.SynchronousClassLoader.prototype.loadClass = function (qualifiedClassName)
{
    var classNameRegex = new RegExp("\\.", "g");
    var potentialURL = qualifiedClassName.replace(classNameRegex, "/");
    potentialURL = this.dynamicClassBaseUrl + potentialURL;
    potentialURL += ".js";
    this.xmlHttpRequest.open("GET", potentialURL, false);
    this.xmlHttpRequest.send("");
    if (this.xmlHttpRequest.status == 404)
    {
        alert("Required Class " + qualifiedClassName + " cannot be loaded.");
        throw $CreateException(new Error("Cannot continue, missing required class " + qualifiedClassName), new Error());
    }
    return this.xmlHttpRequest.responseText;
};
guice.loader.SynchronousClassLoader.className = "guice.loader.SynchronousClassLoader";
guice.loader.SynchronousClassLoader.injectionPoints = function (t)
{
    var p;
    switch (t)
    {
        case 0:
            p =  [];
            p.push({n:'xmlHttpRequest', r:'1'});
            p.push({n:'dynamicClassBaseUrl', r:'1'});
            break;
        default :
            p =  [];
            break;
    }
    return p;
};
